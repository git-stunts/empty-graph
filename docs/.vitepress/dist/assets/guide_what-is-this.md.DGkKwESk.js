import{_ as e,c as o,o as i,ae as s}from"./chunks/framework.DvGhUH3j.js";const p=JSON.parse('{"title":"What is this?","description":"","frontmatter":{},"headers":[],"relativePath":"guide/what-is-this.md","filePath":"guide/what-is-this.md"}'),a={name:"guide/what-is-this.md"};function r(n,t,h,d,l,u){return i(),o("div",null,[...t[0]||(t[0]=[s('<h1 id="what-is-this" tabindex="-1">What is this? <a class="header-anchor" href="#what-is-this" aria-label="Permalink to &quot;What is this?&quot;">​</a></h1><p><strong>EmptyGraph</strong> is a graph database that subverts Git&#39;s internal object model to store structured data invisibly.</p><p>It is a <strong>Git Stunt</strong>: a solution so unorthodox that if Linus Torvalds saw it, he would stop what he was doing, remove his glasses, rub his exhausted eyes, sigh deeply, and then, after a long silence, mutter: <em>&quot;You know what? Have fun,&quot;</em> shake his head, and walk away.</p><h2 id="the-core-subversion" tabindex="-1">The Core Subversion <a class="header-anchor" href="#the-core-subversion" aria-label="Permalink to &quot;The Core Subversion&quot;">​</a></h2><p>Git is usually used to track files. <code>EmptyGraph</code> subverts this by using Git&#39;s Directed Acyclic Graph (DAG) to store structured data <strong>in the commits themselves</strong>.</p><p>Because all commits point to the &quot;Empty Tree&quot; (<code>4b825dc642cb6eb9a060e54bf8d69288fbee4904</code>), your data does not exist as files in the working directory—it exists entirely within the Git object database.</p><h3 id="why-do-this" tabindex="-1">Why do this? <a class="header-anchor" href="#why-do-this" aria-label="Permalink to &quot;Why do this?&quot;">​</a></h3><p>If you’re looking for the most &quot;practical&quot; way to build a database, you’d reach for Postgres. But the goal here isn&#39;t conventional efficiency; it’s <strong>first-principles engineering</strong>.</p><p>When we use Git to perform these &quot;stunts,&quot; we accidentally inherit properties that take months to build into a standard SQL-based app:</p><ul><li><strong>Offline-First Synchronization:</strong> Git&#39;s distributed model handles replication for free.</li><li><strong>Cryptographic Non-Repudiation:</strong> Every node&#39;s SHA proves its integrity and ancestry.</li><li><strong>Universal Tooling:</strong> Use <code>git log</code>, <code>git show</code>, and <code>git branch</code> to inspect your database.</li><li><strong>Infinite Point-in-Time Recovery:</strong> The reflog ensures you never truly lose a &quot;deleted&quot; node.</li></ul><h2 id="the-performance-stunt" tabindex="-1">The Performance &quot;Stunt&quot; <a class="header-anchor" href="#the-performance-stunt" aria-label="Permalink to &quot;The Performance &quot;Stunt&quot;&quot;">​</a></h2><p>Git is terrible at &quot;future&quot; lookups (finding children of a parent). To fix this, EmptyGraph builds a <strong>Secondary Roaring Bitmap Index</strong>.</p><p>This index provides O(1) lookups in both directions, making it 10,000x faster than raw Git traversal for complex graph queries, while still storing that index <em>back into Git</em> as a series of sharded blobs.</p><h2 id="is-this-production-ready" tabindex="-1">Is this production ready? <a class="header-anchor" href="#is-this-production-ready" aria-label="Permalink to &quot;Is this production ready?&quot;">​</a></h2><p>EmptyGraph is a <strong>stunt</strong>, not a product.</p><p>It&#39;s proof that Git&#39;s data model is more powerful than people realize. It&#39;s a legitimate tool for specific use cases (like AI agent memory or audit trails), but it&#39;s not a replacement for purpose-built graph databases like Neo4j if you need ACID transactions or multi-user row-level security.</p><p><strong>Use it when Git&#39;s properties align with your needs. Don&#39;t use it just because it&#39;s clever.</strong></p>',17)])])}const g=e(a,[["render",r]]);export{p as __pageData,g as default};
